---
title: CS886 Assignment 1
subtitle: Report
---

- Returns a list of duplicates instaed of just handling the first duplicate.

## How much of the game was realised, and how much has been verified?
The game was fully realized using the requirements given. All commands have been implemented, verified and error handled. If the user inputs an invalid command, then the invalid command line will print. Most of the implementation has also been specified with pre/post conditions along with invariants where loops are present.

## Which parts of the game was verified
#### Common.dfy
The verification approach started from the root functions. All functions which have been used in Common.dfy have either pre-conditions and/or post-conditions to ensure their correctness.

#### Commands.dfy
Commands.dfy have their methods with specifications added. The process and fromString method have not been verified as I was unsure how to handle it, and was confident that verification of the respective process-command methods and the Common.dfy methods they each use was sufficient verification. Each command's process method contains verification such as argument lengths and ensuring they return the right type. This was done to make it easier to know if a command is invalid since any command which does not adhere to the specification would return Nothing and can be handled with an Invalid Command statement as seen in Main.dfy.

#### Main.dfy
I attempted creating invariants in the main while-true loop to make statements about the correct state behavior of the game. Such that when not inGame, the state variables tracking the secret and turns are correct, allowing verification such that a bad state cannot be reached. The commented invariants I had trouble proving. I chose to verify whether variables are just or not as I allow optionals, but once we get to processing the commands as "game logic" I want to make sure the arguments are ```Just``` to avoid null pointers.

For guesses I try to verify user input as much as possible such that a bad state cannot be reached. I wanted to make sure that the game state is correct when guessing (finished or not finished). The commented post condition in ```evaluateGuess``` is ensuring that yay changes value from 0 if a correct placement is found. I wanted to ensure that yay works properly as an intended counter. I had some issues proving this condition hence the comment.

I chose to include as much verification as possible on my helpers to ensure that the logic for extracting information about the game adheres to design by contract. I am trying to avoid null pointers, bad indexes, and making sure the function actually does what it is supposed to do. This can be seen in my ```areAllElementsUnique``` method where i ensure that no two same items occur in a list. Wherever there are loops in my helpers I try to have invariants which state some "truth" about the loop, in order to verify that my loops are correct.

I had some trouble with verifying the ```getDuplicateElements``` method where I wanted to make sure the method behaves correctly. I had some trouble proving these statements as well. Instead of relying on the post-condition, at the end of this method I chose to assert the statement as well to make sure it held.

The huge switch case in the REPL method does not have any verification in itself, as this is more so handled by the inner methods which handle the specific cases. The outer REPL method just stitches the game logic together but the main decision making once a command is issued is within the smaller methods, which is why those are verified but not the REPL method (other than invariants).

## Appraoch to verification
My approach to verification was to make sure no bad states can be reached. I tried as much as possible to mitigate any null pointers that could occur, and to make sure that my preconditions specified the intended behavior for more complicated methods. I wanted to make sure the root methods (core helpers) were well verified such that the kernel of the game would not break. This meant attempting to verify most methods used from the ```Common.dfy```. I tried to create invariants where loops are present to make statements about what a correct state in the loop would look like.

## Features of Dafny used
---placeholder----

## How confident am I that my implementation is Secure-By-Design?
I am confident that my implementation is secure by design. I have verified most of the code base leaving only a few unverified sections. The combination of defensive and offensive programming allows a strong sense of confidence that I have mitigated bad states, user error, and malicious inputs.

## What tests have been made redundant through Secure-By-Design practices
Most of the bad user input tests have been made reduntant. The malformed tests are no longer needed as I verify user input quite a lot. Checking the game state and running commands to check for correct output based on the game state may also not be needed anymore due to the invariants and specification relating to the game state.

## Do you still need to supply a test infrastructure
I think its good to have both verification and tests, to ensure that the specifications havent missed anything. Even though they might be redundant, it provides an extra layer of assurance that the implementation is correct. The pre-conditions and post-conditions may be verifiable, however they may also differ from the test which describes intended behavior, therefore I think its good to have both. Simple tests such as user input validation can be negated through verification in my opinion. More complex behavior should be verified through Dafny, but also should have tests for some assurance.

<!-- EOF -->
